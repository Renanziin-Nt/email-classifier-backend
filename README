 Email Classifier API with WebSocket

Uma API moderna para classificação inteligente de emails com suporte a WebSockets para atualizações em tempo real.
🚀 Funcionalidades Principais

    🤖 Classificação AI: Identifica emails produtivos vs improdutivos

    💬 Respostas Automáticas: Gera respostas contextualizadas

    ⚡ WebSocket Support: Atualizações em tempo real

    📁 Multi-format: Suporte a texto, TXT e PDF

    🎯 Async Processing: Processamento assíncrono com jobs

    🔒 Rate Limiting: Proteção contra abuso

    🌐 CORS Configurado: Pronto para frontend

🛠️ Tecnologias Utilizadas

    Python 3.12 + FastAPI - Backend moderno e rápido

    WebSocket - Comunicação em tempo real

    Scikit-learn - Machine Learning integrado

    NLTK - Processamento de linguagem natural

    Google Gemini + Hugging Face - APIs de IA opcionais

    Uvicorn - Servidor de alta performance

📦 Instalação Rápida
bash

# 1. Clone e entre na pasta
git clone https://github.com/seu-usuario/email-classifier-backend.git
cd email-classifier-backend

# 2. Ambiente virtual
python -m venv venv
source venv/bin/activate  # Linux/Mac
# ou
venv\Scripts\activate     # Windows

# 3. Instale dependências
pip install -r requirements.txt

# 4. Recursos NLP
python -c "
import nltk
nltk.download('punkt')
nltk.download('stopwords') 
nltk.download('punkt_tab')
print('✅ NLP resources installed!')
"

# 5. Configure (opcional)
cp .env.example .env
# Edite .env com suas API keys

⚡ Como Executar
Desenvolvimento com Auto-reload
bash

uvicorn app.main:app --reload --host 0.0.0.0 --port 8000

Produção
bash

uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4

Com Docker
bash

docker build -t email-classifier-api .
docker run -p 8000:8000 email-classifier-api

🔌 WebSocket - Como Usar
Conexão WebSocket
javascript

// Exemplo de cliente WebSocket
const socket = new WebSocket('ws://localhost:8000/ws/job-status/{job_id}');

socket.onmessage = (event) => {
    const data = JSON.parse(event.data);
    console.log('Status update:', data);
};

socket.onopen = () => {
    console.log('WebSocket connected!');
};

Exemplo de Fluxo

    Crie um job via POST /classify-email

    Conecte WebSocket com o job_id retornado

    Receba updates em tempo real

    Conexão fecha automaticamente quando o job termina

📡 API Endpoints
POST /classify-email

Cria um novo job de classificação.

Body:

    text: string (opcional) - Texto do email

    file: file (opcional) - Arquivo TXT/PDF

Response:
json

{
  "job_id": "uuid-string",
  "status": "pending",
  "message": "Job created successfully"
}

GET /job-status/{job_id}

Verifica status do job (polling tradicional).

Response:
json

{
  "job_id": "uuid-string",
  "status": "processing",
  "progress": 50,
  "current_step": "Classifying email...",
  "result": null,
  "error": null
}

WebSocket /ws/job-status/{job_id}

Conexão em tempo real - Recebe updates automáticos.
DELETE /job/{job_id}

Remove job da memória.
GET /health

Status da API e jobs ativos.
🎯 Exemplos de Uso
cURL - Criar Job
bash

# Com texto
curl -X POST "http://localhost:8000/classify-email" \
  -H "Content-Type: application/json" \
  -d '{"text": "Preciso de ajuda com erro no sistema"}'

# Com arquivo
curl -X POST "http://localhost:8000/classify-email" \
  -F "file=@email.pdf"

JavaScript - WebSocket
javascript

// Conectar ao WebSocket
async function connectWebSocket(jobId) {
    const ws = new WebSocket(`ws://localhost:8000/ws/job-status/${jobId}`);
    
    ws.onmessage = (event) => {
        const data = JSON.parse(event.data);
        updateUI(data);
    };
    
    ws.onclose = () => {
        console.log('Connection closed - job completed');
    };
}

Python - Cliente Completo
python

import requests
import json
import asyncio
import websockets

# Criar job
response = requests.post("http://localhost:8000/classify-email", 
    json={"text": "Olá, preciso de suporte técnico urgente"}
)
job_id = response.json()["job_id"]

# Conectar WebSocket
async def track_job():
    async with websockets.connect(f"ws://localhost:8000/ws/job-status/{job_id}") as ws:
        async for message in ws:
            data = json.loads(message)
            print(f"Progress: {data['progress']}% - {data['message']}")
            
            if data['status'] == 'completed':
                print("Resultado:", data['result'])
                break

asyncio.run(track_job())

⚙️ Configuração
Variáveis de Ambiente (.env)
env

FRONTEND_URL=http://localhost:3000
GEMINI_API_KEY=your_gemini_key_here
HF_API_KEY=your_huggingface_key_here
HOST=0.0.0.0
PORT=8000
DEBUG=True

Sem Variáveis de Ambiente

O sistema funciona perfeitamente sem APIs externas usando:

    ✅ Modelo Machine Learning local

    ✅ Templates inteligentes de resposta

    ✅ Processamento completo offline

🏗️ Estrutura do Projeto
text

app/
├── main.py                 # FastAPI app + WebSocket handlers
├── models/
│   ├── schemas.py          # Pydantic models
│   └── ml_model.py         # ML model training/prediction
├── services/
│   ├── ai_service.py       # AI integration layer
│   ├── classifier.py       # Email classification
│   ├── response_generator.py # Response generation
│   └── email_processor.py  # Text processing
└── utils/
    └── logging_utils.py    # Logging configuration

🔒 Rate Limiting

O sistema inclui proteção automática:

    ⏰ 500ms entre requests de status

    📊 Log de tentativas excessivas

    🛡️ Proteção por IP e endpoint

🐛 Solução de Problemas
Erro de CORS
bash

# Verifique se o FRONTEND_URL está correto no .env
# Ou ajuste no código:
allow_origins=["http://localhost:3000", "http://127.0.0.1:3000"]

WebSocket Não Conecta
javascript

// Verifique se o backend está rodando
// E se o job_id existe
console.log('WebSocket status:', socket.readyState);

Erro de NLP Resources
bash

python -c "import nltk; nltk.download('punkt'); nltk.download('stopwords')"

📊 Monitoramento
Logs em Tempo Real
text

📊 Job a1b2c3d4: processing - Processing email... (30%)
✅ Job a1b2c3d4 completed successfully!
⚠️ Rate limit exceeded for 127.0.0.1 on /job-status/...

Health Check
bash

curl http://localhost:8000/health
# {"status":"healthy","active_jobs":3,"version":"1.0.0"}

🚀 Deploy em Produção
1. Traditional Server
bash

uvicorn app.main:app --host 0.0.0.0 --port 8000 --workers 4

2. Docker
dockerfile

FROM python:3.12-slim
COPY . /app
WORKDIR /app
RUN pip install -r requirements.txt
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]

3. Cloud (AWS/Google Cloud)

    Configure reverse proxy para WebSocket

    Ajuste timeouts para conexões longas

    Configure SSL para WSS (WebSocket Secure)

🤝 Contribuindo

    Fork o projeto

    Crie sua feature branch (git checkout -b feature/AmazingFeature)

    Commit (git commit -m 'Add AmazingFeature')

    Push (git push origin feature/AmazingFeature)

    Abra um Pull Request